const { Client } = require('pg');
const fs = require('fs');
const path = require('path');

// Database connection string
const DATABASE_URL = 'postgresql://postgres:SuFkUevgonaZFXJiJeczFiXYTlICHVJL@shortline.proxy.rlwy.net:33452/railway';

// Create backup filename with timestamp
const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
const backupFilename = `pre_dropdown_migration_${timestamp}.sql`;
const backupPath = path.join(__dirname, backupFilename);

console.log('ğŸ”„ Creating database backup using direct connection...');
console.log(`ğŸ“ Backup file: ${backupPath}`);

async function createBackup() {
  const client = new Client({
    connectionString: DATABASE_URL,
    ssl: { rejectUnauthorized: false }
  });

  try {
    await client.connect();
    console.log('âœ… Connected to database');

    // Get all tables
    const tablesQuery = `
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      ORDER BY table_name
    `;
    
    const tablesResult = await client.query(tablesQuery);
    const tables = tablesResult.rows.map(row => row.table_name);
    
    console.log(`ğŸ“Š Found ${tables.length} tables: ${tables.join(', ')}`);

    let backupContent = `-- Database Backup created on ${new Date().toISOString()}\n`;
    backupContent += `-- Generated by direct connection (bypassing pg_dump version mismatch)\n\n`;

    // For each table, get structure and data
    for (const table of tables) {
      console.log(`ğŸ”„ Processing table: ${table}`);
      
      // Get table structure
      const structureQuery = `
        SELECT column_name, data_type, is_nullable, column_default
        FROM information_schema.columns 
        WHERE table_name = $1 AND table_schema = 'public'
        ORDER BY ordinal_position
      `;
      
      const structureResult = await client.query(structureQuery, [table]);
      
      backupContent += `\n-- Table: ${table}\n`;
      backupContent += `CREATE TABLE IF NOT EXISTS "${table}" (\n`;
      
      const columns = [];
      for (const col of structureResult.rows) {
        let colDef = `  "${col.column_name}" ${col.data_type}`;
        if (col.is_nullable === 'NO') {
          colDef += ' NOT NULL';
        }
        if (col.column_default) {
          colDef += ` DEFAULT ${col.column_default}`;
        }
        columns.push(colDef);
      }
      
      backupContent += columns.join(',\n') + '\n);\n\n';
      
      // Get table data
      const dataQuery = `SELECT * FROM "${table}"`;
      const dataResult = await client.query(dataQuery);
      
      if (dataResult.rows.length > 0) {
        backupContent += `-- Data for table: ${table}\n`;
        
        for (const row of dataResult.rows) {
          const columns = Object.keys(row);
          const values = Object.values(row).map(val => {
            if (val === null) return 'NULL';
            if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
            return val;
          });
          
          backupContent += `INSERT INTO "${table}" (${columns.map(c => `"${c}"`).join(', ')}) VALUES (${values.join(', ')});\n`;
        }
        backupContent += '\n';
      }
    }

    // Write backup file
    fs.writeFileSync(backupPath, backupContent);
    
    const fileSize = fs.statSync(backupPath).size;
    console.log(`âœ… Backup created successfully!`);
    console.log(`ğŸ“Š File size: ${fileSize} bytes`);
    console.log(`ğŸ“ Location: ${backupPath}`);

  } catch (error) {
    console.error('âŒ Backup failed:', error.message);
  } finally {
    await client.end();
  }
}

createBackup().catch(console.error); 