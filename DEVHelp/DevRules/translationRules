must add translation to proper language file to @/translations  folder
1. Understand the Context and Purpose
Before translating, analyze the surrounding UI, code comments, business logic, and user flow.
Identify the target audience (e.g., end-users, admin, legal, compliance, etc.).
If the text is part of a legal document, notice, policy, or agreement, recognize the legal intent and implications.
2. Produce Lawyer-Level Translation
Translate using formal, unambiguous legal language. Avoid colloquialisms, contractions, or vague terms.
Replicate the structure and tone of legal documents—prefer clarity, completeness, and precision.
Use jurisdiction-appropriate legal terms (e.g., Israeli law, EU law) if relevant.
3. Stay True to the Source and Avoid Over-Localization
Do not add, omit, or reinterpret information. Translate the meaning as-is, preserving all nuances and obligations.
Maintain any references to laws, articles, or clauses exactly.
4. Check for Contextual Fit
Ensure the translation fits the specific place in the UI or flow (e.g., form field, tooltip, dialog).
Adapt for gender, number, and formality where appropriate (as per the project's language style guide).
5. Preserve Variable Interpolation and Markup
Maintain all code variables/placeholders (e.g., {username}, %date%, {{amount}}) exactly as in the source.
Never break string formatting, HTML tags, or placeholders.
If the source uses ICU message format or similar, preserve it exactly.
6. Legal Consistency and Compliance
Use consistent terminology across all legal texts in the project.
Reference existing project translations for recurring legal terms or phrases to ensure consistency.
Always check if there are approved legal glossaries or translation memory—reuse those terms.
7. Clarity, Brevity, and No Machine-Literal Translation
Avoid word-for-word, machine-like translation. Ensure the output is natural, but legally precise.
If a phrase cannot be translated directly, rewrite it to preserve the legal intent.
8. Testing and QA
Ensure the translation renders correctly in the frontend (no broken formatting, cutoff text, or misaligned placeholders).
Test the translation in all relevant UI components (responsive, different user roles, etc.).
9. Database-Driven Content Management for Dropdowns
When encountering dropdown components with hardcoded values, ALWAYS migrate them to the database:
- Insert all dropdown options into the `content_items` table with `component_type = 'option'`
  - Use sequential numbering: `_option_1`, `_option_2`, `_option_3`, etc.
- Create translations for all languages (EN/HE/RU) in `content_translations` table
- Update components to use `useContentApi()` and `getContent()` instead of hardcoded arrays
- Comment out old translation keys in JSON files with `__MIGRATED_` prefix
- NEVER leave hardcoded dropdown values in components

Example dropdown migration:
```javascript
// ❌ WRONG - Hardcoded values
const options = [
  { value: 'option_1', label: 'Hardcoded Text' },
  { value: 'option_2', label: 'Another Hardcoded Text' }
];

// ✅ CORRECT - Database-driven
const options = [
  { value: 'option_1', label: getContent('field_name_option_1', 'field_name_option_1') },
  { value: 'option_2', label: getContent('field_name_option_2', 'field_name_option_2') }
];
```

10. Screen Location Naming Conventions
⚠️ **CRITICAL**: Always reference `SystemAnalyse/procceessesPagesInDB.md` for the authoritative screen location naming conventions. This file MUST be consulted before creating any new content_items entries.

All screen locations in the `content_items` table MUST follow specific naming patterns for consistency:

- **Process-Specific Prefixes**: Always use the process name as prefix
  - Mortgage calculator: `mortgage_step1`, `mortgage_step2`, `mortgage_step3`, `mortgage_step4`
  - Credit calculator:  `credit_step1`, `credit_step2`, `credit_step3`, `credit_step4`
  - Refinance mortgage: `refinance_credit_1`, `refinance_credit_2`, `refinance_credit_3`, `mortgage_step4`
  - Refinance credit:   `refinance_credit_1`, `refinance_credit_2`, `refinance_credit_3`, `refinance_credit_4`

- **Menu and Navigation**:
  - Sidebar menu: `sidebar`
  - Footer: `footer`

- **Sub-Section Naming**: For multi-section steps, append a clear suffix
  - Headers:        `credit_step3_header`
  - Personal info:  `credit_step3_personal_info`
  - Employment:     `credit_step4_employment`
  - Income:         `credit_step4_income`

- **NEVER use generic names** like `step3_header`, `form_section`, `page_content`
- **Consistency Rule**: Follow the exact patterns in the database documentation (`SystemAnalyse/procceessesPagesInDB.md`).

**⚠️ CRITICAL: Screen Location Precision Requirements**
**MANDATORY**: Before creating any content_items entries, ALWAYS check `SystemAnalyse/procceessesPagesInDB.md` for the exact screen_location values to use.

The `screen_location` field in `content_items` MUST be an EXACT match to what the frontend passes to `useContentApi()`:

- **Exact Match Required**: The `screen_location` value MUST match the parameter passed to `useContentApi('screen_location')`
- **No Variations Allowed**: Even small differences like `mortgage_calculation` vs `calculate_mortgage_1` will cause content to NOT load
- **Case Sensitive**: `mortgage_step1` ≠ `Mortgage_Step1` ≠ `MORTGAGE_STEP1`
- **Frontend Dependency**: Always check the React component code to see what `screen_location` is being used

**Examples of Precise Matching:**
```typescript
// ✅ CORRECT - Frontend component uses 'mortgage_calculation'
const { getContent } = useContentApi('mortgage_calculation')
// Database must have: screen_location = 'mortgage_calculation'

// ❌ WRONG - Mismatch will cause content not to load
// Frontend: useContentApi('mortgage_calculation')
// Database: screen_location = 'calculate_mortgage_1'  // ❌ NO MATCH!
```

**Verification Steps:**
1. **Check Frontend Code**: Search for `useContentApi('...')` calls in React components
2. **Match Exactly**: Ensure database `screen_location` matches the parameter exactly
3. **Test API**: Verify `/api/content/{screen_location}/{language}` returns data
4. **Update Documentation**: Document any new screen_location values used

Content Key Naming Patterns:
- **Field Labels**: `{process}_{field_name}` (e.g., `calculate_credit_education`)
- **Placeholders**: `{process}_{field_name}_ph` (e.g., `calculate_credit_education_ph`)
- **Options**: `{process}_{field_name}_option_{number}` (e.g., `calculate_credit_education_option_1`)
- **Buttons**: `{process}_{step}_button_type` (e.g., `calculate_credit_step2_next_button`)
- **Titles**: `{process}_{step}_title` (e.g., `calculate_credit_step2_title`)

Screen Location Categories by Process:
```yaml
mortgage_calculator:
  - mortgage_step1, mortgage_step2, mortgage_step3, mortgage_step4
  
credit_calculator:
  - calculate_credit_1, calculate_credit_2
  - calculate_credit_3_header, calculate_credit_3_personal_info
  - calculate_credit_4_header, calculate_credit_4_employment, calculate_credit_4_income
  
refinance_calculator:
  - refinance_step1, refinance_step2, refinance_step3, refinance_step4
```

11. Migration Guidelines and Database Schema
When migrating content from translation.json files to the database:

Database Tables:
- **content_items**: Stores content metadata and structure
  - `content_key`: Unique identifier following naming patterns above
  - `component_type`: 'field_label', 'placeholder', 'option', 'button', 'title', 'text'
  - `category`: Logical grouping (e.g., 'personal_details', 'income_details', 'navigation')
  - `screen_location`: Page/step identifier following naming conventions
  - `is_active`: Boolean flag for content availability
  - `legacy_translation_key`: Reference to original translation.json key

- **content_translations**: Stores actual translated content
  - `content_item_id`: References content_items.id
  - `language_code`: 'en', 'he', 'ru'
  - `content_value`: The actual translated text
  - `status`: 'approved', 'draft', 'review', 'archived'

Migration Process:
1. **Analyze existing translation keys** for patterns and groupings
2. **Create content_items entries** with proper naming conventions
3. **Insert translations** for all three languages (EN/HE/RU)
4. **Update components** to use database content via API
5. **Comment out migrated keys** in translation.json with `__MIGRATED_` prefix
6. **Test all language variations** and UI components
7. **Document screen locations** in this file for future reference

Example Migration SQL:
```sql
-- Insert content item
INSERT INTO content_items (content_key, component_type, category, screen_location, legacy_translation_key)
VALUES ('calculate_credit_education', 'field_label', 'personal_details', 'calculate_credit_2', 'calculate_credit_education');

-- Insert translations
INSERT INTO content_translations (content_item_id, language_code, content_value, status)
SELECT id, 'en', 'Education Level', 'approved' FROM content_items WHERE content_key = 'calculate_credit_education';
```

12. Confidentiality and Compliance
Never leak, store, or transmit translation content outside approved systems.
Handle all legal content as confidential.

13. Duplicate Prevention & Process-Specific Translations
Every **content_key + screen_location** pair **MUST be unique** in `content_items` across the entire system. Re-using the same `content_key` for different processes (mortgage vs credit vs refinance) is **FORBIDDEN**, even if the UI text looks identical.

- **Process Isolation**: Each process maintains its own namespace. Example for **step 4 (results page)** which is common across all calculators:
  - Mortgage:     `mortgage_step4_result_title`
  - Credit:       `calculate_credit_4_result_title`
  - Refinance:    `refinance_step4_result_title`
  - Refinance-Credit: `refinance_credit_4_result_title`

- **Editing Independence**: Editors MUST be able to update text for one process without affecting the others. Never share a single translation row across processes.

- **Database Constraint**: Enforce a composite **UNIQUE(content_key, screen_location)** index (already present) AND follow naming conventions so keys never collide.

- **Migration Checklist**:
  1. Scan existing `content_items` for duplicate `content_key` values across different `screen_location`s.
  2. If found, split into process-specific keys using the naming scheme above.
  3. Add translations for all three languages (EN/HE/RU).
  4. Verify with:
     ```sql
     SELECT content_key, ARRAY_AGG(DISTINCT screen_location) AS screens
     FROM content_items
     GROUP BY content_key
     HAVING COUNT(DISTINCT screen_location) > 1;
     ```
  5. QA: Load each step in the frontend and ensure text can be edited independently per process.

- **CI Guard**: Add automated lint / SQL check that fails the pipeline if a new PR introduces a duplicate `content_key` for a different `screen_location`.

This section makes the translation system **bullet-proof** against accidental key re-use and guarantees full editorial flexibility for every calculator process.

13. Dropdown Database Convention
**Reference**: Always check `SystemAnalyse/procceessesPagesInDB.md` for correct screen_location values before implementing dropdown migrations.

When migrating dropdown components to the database, follow this exact structure:

**Database Structure for Dropdowns:**
All dropdown components consist of multiple related entries in `content_items`, linked by the **screen_location** field:

1. **Field Label** (component_type = 'field_label')
   - Pattern: `{process}_{field_name}`
   - Example: `calculate_credit_education`

2. **Placeholder** (component_type = 'placeholder') 
   - Pattern: `{process}_{field_name}_ph`
   - Example: `calculate_credit_education_ph`

3. **Options** (component_type = 'option')
   - Pattern: `{process}_{field_name}_option_{number}`
   - Sequential numbering: `_option_1`, `_option_2`, `_option_3`, etc.
   - Examples: `calculate_credit_education_option_1`, `calculate_credit_education_option_2`

**Step Association via screen_location:**
All dropdown components for the same step share the same `screen_location` value:

```sql
-- All education dropdown components belong to step 2
INSERT INTO content_items (content_key, component_type, screen_location, category, ...)
VALUES 
('calculate_credit_education', 'field_label', 'calculate_credit_2', 'personal_details', ...),
('calculate_credit_education_ph', 'placeholder', 'calculate_credit_2', 'personal_details', ...),
('calculate_credit_education_option_1', 'option', 'calculate_credit_2', 'personal_details', ...),
('calculate_credit_education_option_2', 'option', 'calculate_credit_2', 'personal_details', ...),
('calculate_credit_education_option_3', 'option', 'calculate_credit_2', 'personal_details', ...);
```

**Frontend Grouping Logic:**
The frontend uses `useContentApi('screen_location')` to fetch ALL content for a step, then filters by content_key patterns to group dropdown components together.

**Migration Requirements:**
- NEVER mix dropdown components across different screen_locations
- ALL options for a dropdown MUST use sequential numbering starting from 1
- Field name MUST be consistent across label, placeholder, and all options
- Use appropriate category values ('personal_details', 'income_details', 'loan_parameters', etc.)